Q Smaller window in a string containing all the characters of a another string : 

class Solution {
public:
    string minWindow(string s, string t) {
        string ans="";
		//could use vector of size 256 here but for simplicity
        unordered_map <char,int> mp1;
        unordered_map <char,int> mp2;
        int mct=0;
        int dmct=t.length();
        for(auto it : t)
            mp2[it]++;

        int i=0;
        int j=0;
        while(true){
            bool f1=false;
            bool f2=false;
            // cout<<i<<" "<<s.length()<<" "<<mct<<" "<<dmct<<endl;
            while((i<s.length()) && (mct<dmct)){
                mp1[s[i]]++;
                if(mp1[s[i]]<=mp2[s[i]])
                    mct++;
                f1=true;
                i++;
                // cout<<"function 1";
            }
            while((j<i) && (mct==dmct)){
                string pans=s.substr(j,i-j);
                // cout<<pans<<endl;
                if(ans.length()==0 or ans.length()>pans.length())
                    ans=pans;
                
                if(mp1[s[j]]==1){
                    mp1.erase(s[j]);
                }else{
                    mp1[s[j]]--;
                }
                if(mp1[s[j]]<mp2[s[j]])
                    mct--;
                f2=true;
                j++;
            }
            if(f1==false and f2==false)
                break;
        }
        // cout<<i<<" "<<s.length()<<" "<<mct<<" "<<dmct<<endl;
        return ans;
    } 
};

Q Alien Dictionary using topo sort : 
class Solution
{
    
    public static class Edge {
        int v = 0, w = 0;

        Edge(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }

    public static void addEdge(ArrayList<Edge>[] graph, int u, int v, int w) {
        graph[u].add(new Edge(v, w));
    }
    
    public String findOrder(String [] dict, int N, int K)
    {
        // Write your code here
        ArrayList<Edge>[] graph = new ArrayList[K];
        for ( int i = 0 ; i < K ; i ++ ){
            graph[i]  = new ArrayList<>();
        }
        
        for (int i = 0 ; i < dict.length - 1  ; i ++ ){
            
            String str1 = dict[i];
            String str2 = dict[i + 1 ];
            
            int minSize = Math.min(str1.length() , str2.length());
            for( int j = 0 ; j < minSize ; j ++){
                
                if( !Objects.equals(str1.charAt(j) , str2.charAt(j)) ){
                    int u =  str1.charAt(j) - 'a' ;
                    int v = str2.charAt(j) - 'a';
                    addEdge(graph, u , v , 0);
                    break;
                }
            }
            
        }
        StringBuilder newAnssbf = new StringBuilder();
        ArrayList<Integer> ans = topologicalOrder(graph);
        for (int i = ans.size() - 1; i >=  0 ; i--){
            char ch  = (char)( 'a' + ans.get(i) );
            newAnssbf.append(ch);
        }
        
        
        return newAnssbf.toString();
        
    }
  
   public static void dfs_topo(ArrayList<Edge>[] graph, int src, boolean[] vis, ArrayList<Integer> ans) {
        vis[src] = true;
        for (Edge e : graph[src]) {
            if (!vis[e.v])
                dfs_topo(graph, e.v, vis, ans);
        }
        ans.add(src);
    }

    public static ArrayList<Integer> topologicalOrder(ArrayList<Edge>[] graph) {
        ArrayList<Integer> ans = new ArrayList<>();

        int N = graph.length;
        boolean[] vis = new boolean[N];
        //  for(ArrayList<Edge> i : graph){
        //      for(Edge j :i  ){
        //      System.out.print(j.v + " ") ;
        //      }
        //      System.out.println();
        //  }
        for (int i = 0; i < N; i++) {
            if (!vis[i])
                dfs_topo(graph, i, vis, ans);
        }
        
        return ans;
    }
}

Q Swapping pairs to make sum equal in 2 arrays : 
 long findSwapValues(long a[], int n, long b[], int m) {
        // Your code goes here
        Arrays.sort(a);
        Arrays.sort(b);
        
        long sum1 = 0 ; 
        long sum2  = 0 ; 
        
        for ( long i : a ){
            sum1  += i ;
        }
        for (long j : b ){
            sum2 += j;
        }
        
        if ((sum1 - sum2)%2 != 0  ){
            return -1 ; }
        
        long target = (sum1 - sum2)/2;
        

        // If the target is the maximum value, return -1.


        int i = 0, j = 0;
        while (i < n && j < m) {
            long diff = a[i] - b[j] ;

            // If the difference is equal to the target, return 1.
            if (diff == target) {
                return 1;
            }
            // If the difference is less than the target, increment i.
            else if (diff < target)
                i++;
            // If the difference is greater than the target, increment j.
            else
                j++;
        }

        // If no values are found to swap, return -1.
        return -1;
    }
